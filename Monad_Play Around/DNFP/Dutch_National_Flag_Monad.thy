theory Dutch_National_Flag_Monad
imports 
  "Dutch_National_Flag_Monad_Definitions_Lemmas"
begin

section\<open>DNFP\<close>
text\<open>A version using a state monad for storing the list/array that is being sorted\<close>
fun dnfp_mon:: "nat \<Rightarrow> (env, unit) state" where
  case0:"dnfp_mon 0  = skip"|
  caseN:"dnfp_mon (Suc n) = do {
                        (h, j) \<leftarrow> get (\<lambda>e. (high e, i e));
                        (if h > j then do{
                          loop_update_action;
                          dnfp_mon n
                         }
                       else skip
                      )}"

section\<open>Lemmas\<close>
subsection\<open>Hoare proofs\<close>

definition loop_update_action_inv :: "env \<Rightarrow> bool" where
"loop_update_action_inv s \<equiv> (loop_update_action_inv3 s \<and> loop_update_action_inv2 s \<and> loop_update_action_inv1 s)"

lemma loop_update_action_invariants: "spec loop_update_action_inv loop_update_action (GG invariants_Env)"
  by (metis (mono_tags, lifting) GG_def loop_update_action_inv_def loop_update_action_invariantBlue loop_update_action_invariantRed loop_update_action_invariantWhite invariants_Env_def spec_def split_def)

subsection\<open>DNFP_Mon Auxillary lemmas\<close>
lemma dnfp_aux1: "spec (\<lambda>y. length (xs e) = length (xs y)) (dnfp_mon v) (\<lambda>x y. length (xs e) = length (xs y))"
  apply(induction v rule: dnfp_mon.induct)
    apply(simp add: spec_def)
    apply (simp add: skip_def)
  apply(simp only: caseN)
  apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. length (xs e) = length (xs y))"])
  apply(intro cond_rule)
  apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. length (xs e) = length (xs y))"])
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. length (xs e) = length (xs y))"])
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
         apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. length (xs e) = length (xs y))"])
    apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply blast
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def run_state_def)
  by (simp add: skip_def)

lemma dnfp_aux2: "spec (\<lambda>y. high y \<le> high e) (dnfp_mon v) (\<lambda>x y. high y \<le> high e)"
  apply(induction v rule: dnfp_mon.induct)
    apply(simp add: spec_def)
    apply (simp add: skip_def)
  apply(simp only: caseN)
  apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y \<le> high e)"])
  apply(intro cond_rule)
  apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y \<le> high e)"])
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y \<le> high e)"])
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
         apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y \<le> high e)"])
      apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
  apply linarith
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply blast
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def run_state_def)
  by (simp add: skip_def)

lemma dnfp_aux3: "spec (\<lambda>y. low e \<le> low y) (dnfp_mon v) (\<lambda>x y. low e \<le> low y)"
  apply(induction v rule: dnfp_mon.induct)
    apply(simp add: spec_def)
    apply (simp add: skip_def)
  apply(simp only: caseN)
  apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. low e \<le> low y)"])
  apply(intro cond_rule)
  apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. low e \<le> low y)"])
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. low e \<le> low y)"])
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
         apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. low e \<le> low y)"])
      apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply blast
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def run_state_def)
  by (simp add: skip_def)

lemma dnfp_aux4: "spec (\<lambda>y. i e \<le> i y) (dnfp_mon v) (\<lambda>x y. i e \<le> i y)"
  apply(induction v rule: dnfp_mon.induct)
    apply(simp add: spec_def)
    apply (simp add: skip_def)
  apply(simp only: caseN)
  apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i e \<le> i y)"])
  apply(intro cond_rule)
  apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i e \<le> i y)"])
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i e \<le> i y)"])
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
         apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i e \<le> i y)"])
      apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply blast
    apply(simp add: spec_def)
  by (simp add: skip_def)

lemma dnfp_aux5: "spec (\<lambda>y. high y - i y \<le> high e - i e) (dnfp_mon v) (\<lambda>x y. high y - i y \<le> high e - i e)"
  apply(induction v rule: dnfp_mon.induct)
    apply(simp add: spec_def)
    apply (simp add: skip_def)
  apply(simp only: caseN)
  apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y - i y \<le> high e - i e)"])
  apply(intro cond_rule)
  apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y - i y \<le> high e - i e)"])
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y - i y \<le> high e - i e)"])
   apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
  apply (simp add: le_diff_conv)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y - i y \<le> high e - i e)"])
  apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
  apply linarith
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
  apply (simp add: le_diff_conv)
   apply blast
  apply(simp add: spec_def)
  by (simp add: skip_def)

lemma dnfp_aux6: "spec (\<lambda>y. mset (xs e) = mset (xs y)) (dnfp_mon v) (\<lambda>x y. mset (xs e) = mset (xs y))"
  apply(induction v rule: dnfp_mon.induct)
    apply(simp add: spec_def)
    apply (simp add: skip_def)
  apply(simp only: caseN)
  apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. mset (xs e) = mset (xs y))"])
  apply(intro cond_rule)
  apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. mset (xs e) = mset (xs y))"])
       apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply (simp add: Multiset.mset_swap)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. mset (xs e) = mset (xs y))"])
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
         apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. mset (xs e) = mset (xs y))"])
      apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
     apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply (simp add: Multiset.mset_swap)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply blast
  apply(simp add: spec_def)
  by (simp add: skip_def)

lemma dnfp_aux7: "spec (\<lambda>y. i y \<le> high y) (dnfp_mon n) (\<lambda>x y. high y = i y)"
  apply(induction n rule: dnfp_mon.induct)
    apply(simp add: spec_def)
   apply (simp add: skip_def)
  defer
  apply(simp only: caseN)
  apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i y \<le> high y)"])
  apply(intro cond_rule)
  apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i y < high y)"])
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
       apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i y \<le> high y)"])
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
       apply(intro allI; simp)
     apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
      apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i y \<le> high y)"])
      apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
  apply linarith
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
      apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
      apply(intro allI; simp)
  apply blast
   apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def run_state_def)
  apply (simp add: skip_def)
  sorry


subsection\<open>DNFP proof\<close>
lemma dnfp_prepost: "spec (dnfp_pre n e) (dnfp_mon n) (GG (dnfp_post e))"
  apply(induction rule: dnfp_mon.induct)
  unfolding dnfp_pre_def dnfp_pre_aux_def GG_def dnfp_post_def
    apply(simp add: spec_def)
   apply (simp add: skip_def)
  apply(intro conj_rule_right; simp only: caseN)
   apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. length (xs e) = length (xs y))"])
  apply(intro cond_rule)
  apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. length (xs e) = length (xs y))"])
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. length (xs e) = length (xs y))"])
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
         apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. length (xs e) = length (xs y))"])
    apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
        apply(intro allI; simp)
  using dnfp_aux1 apply blast
        apply(simp add: spec_def skip_def)
   apply(intro get_rule; intro allI; clarify)
       apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y \<le> high e)"])
       apply(intro cond_rule)
 apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y \<le> high e)"])
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y \<le> high e)"])
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
         apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y \<le> high e)"])
    apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
       apply(intro allI; simp)
  using dnfp_aux2 apply blast
    apply(simp add: spec_def skip_def)

   apply(intro get_rule; intro allI; clarify)
       apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. low e \<le> low y)"])
       apply(intro cond_rule)
 apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. low e \<le> low y)"])
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. low e \<le> low y)"])
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
         apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. low e \<le> low y)"])
    apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
  using dnfp_aux3 apply blast
  apply(simp add: spec_def skip_def)

   apply(intro get_rule; intro allI; clarify)
       apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i e \<le> i y)"])
       apply(intro cond_rule)
 apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i e \<le> i y)"])
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i e \<le> i y)"])
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
         apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. i e \<le> i y)"])
    apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
  using dnfp_aux4 apply blast
  apply(simp add: spec_def skip_def)

   apply(intro get_rule; intro allI; clarify)
       apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y - i y \<le> high e - i e)"])
       apply(intro cond_rule)
 apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y - i y \<le> high e - i e)"])
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y - i y \<le> high e - i e)"])
  apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
  apply (simp add: le_diff_conv)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y - i y \<le> high e - i e)"])
       apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
  apply linarith
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
    apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
         apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
  apply linarith
    apply(intro allI; simp)
  using dnfp_aux5 apply blast
  apply(simp add: spec_def skip_def)

 apply(intro get_rule; intro allI; clarify)
 apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. mset (xs e) = mset (xs y))"])
       apply(intro cond_rule)
 apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. mset (xs e) = mset (xs y))"])
            apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply (simp add: Multiset.mset_swap)
   apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. mset (xs e) = mset (xs y))"])
  apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
         apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
  apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. mset (xs e) = mset (xs y))"])
  apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
  apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
  apply (simp add: Multiset.mset_swap)
  apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
   apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
    apply(intro allI; simp)
  using dnfp_aux6 apply blast
   apply(simp add: spec_def skip_def)

 apply(intro get_rule; intro allI; clarify)
 apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y \<ge> i y)"])
       apply(intro cond_rule)
 apply(simp add: inc_lowbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y > i y)"])
  apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
       apply(intro allI; simp)
   apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y \<ge> i y)"])
        apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
         apply(intro get_rule; intro allI)
    apply(simp add: spec_def put_def low_Env_def put_state_def get_state_def)
      apply(simp add: dec_highbound_def)
   apply(intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x y. high y \<ge> i y)"])
  apply(simp add: spec_def put_def high_Env_def put_state_def get_state_def)
  apply linarith
   apply(intro allI; simp)
  apply(intro get_rule; intro allI; simp)
  apply(simp add: spec_def put_def xs_Env_def swap_def put_state_def get_state_def)
      apply(simp add: inc_index_def)
  apply(intro get_rule; intro allI; simp)
      apply(simp add: spec_def put_def i_Env_def put_state_def get_state_def)
   apply(intro allI; simp)
  using dnfp_aux7 apply blast 
  by(simp add: spec_def skip_def)

subsection\<open>Invariants proof\<close>

subsubsection\<open>Lemmas\<close>
lemma dnfp_invariantRed_aux: "spec (\<lambda>e. \<forall>x<low e. xs e ! x = 0) (dnfp_mon v) (\<lambda>x e. \<forall>x<low e. xs e ! x = 0)"
 apply(induction v rule: dnfp_mon.induct)
    apply(simp add: spec_def)
    apply (simp add: skip_def)
  apply(simp only: caseN)
  apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x e. (\<forall>x<low e. xs e ! x = 0))"])
  apply(intro cond_rule)
  apply(simp add: inc_lowbound_def)
      apply (intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x e. xs e ! low e = 0 \<and> (\<forall>x<low e. xs e ! x = 0))"])
       apply (simp add: spec_def put_def put_state_def swap_def get_state_def xs_Env_def)
    (*Look here*)
  apply(intro allI)
  defer
       apply(intro allI; simp)
  apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x e. xs e ! low e = 0 \<and> (\<forall>x<low e. xs e ! x = 0))"])
        apply (simp add: spec_def put_def put_state_def get_state_def i_Env_def)
  apply(intro allI; simp)
  apply(intro get_rule; intro allI)
       apply (simp add: spec_def put_def put_state_def get_state_def low_Env_def)
  apply (simp add: less_Suc_eq)
     apply(simp add: dec_highbound_def)
     apply (intro get_rule; intro allI; simp)
      apply(intro seq_rule[of _ _ "(\<lambda>x e. low e \<le> i e \<and> i e \<le> high e \<and> (\<forall>x<low e. xs e ! x = 0))"]) 
       apply (simp add: spec_def get_def put_def get_state_def put_state_def high_Env_def)
  apply (metis Suc_pred le0 le_less_trans less_Suc_eq_le not_less)
      apply(intro allI; simp)
     apply (intro get_rule; intro allI; simp)
      apply (simp add: spec_def get_def put_def get_state_def put_state_def xs_Env_def swap_def)
     apply(simp add: inc_index_def)
     apply (intro get_rule; intro allI; simp)
     apply (simp add: spec_def get_def put_def get_state_def put_state_def i_Env_def)
    apply(intro allI; simp)
  apply blast
    apply(simp add: spec_def)
  apply(simp add: skip_def)
  sorry

lemma dnfp_invariantWhite_aux: "spec (\<lambda>e. \<forall>x. low e \<le> x \<and> x < i e \<longrightarrow> xs e ! x = Suc 0) (dnfp_mon v) (\<lambda>x e. \<forall>x. low e \<le> x \<and> x < i e \<longrightarrow> xs e ! x = Suc 0)"
 apply(induction v rule: dnfp_mon.induct)
    apply(simp add: spec_def)
    apply (simp add: skip_def)
  apply(simp only: caseN)
  apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
  apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>_ e. i e \<ge> low e \<and> high e \<ge> i e \<and> (\<forall>x. low e \<le> x \<and> x < i e \<longrightarrow> xs e ! x = Suc 0))"])
  apply(intro cond_rule)
  apply(simp add: inc_lowbound_def)
     apply (intro get_rule; intro allI; simp)
   apply (simp add: spec_def put_def put_state_def  get_state_def xs_Env_def swap_def get_def i_Env_def low_Env_def return_def run_state_def)
      apply(intro allI)
      apply (simp add: nth_list_update)
  defer
     apply(simp add: dec_highbound_def)
        apply(intro get_rule; intro allI; simp)
    apply(intro seq_rule[of _ _ "(\<lambda>x e. low e \<le> i e \<and> high e \<ge> i e \<and> length (xs e) > high e \<and> (\<forall>x. low e \<le> x \<and> x < i e \<longrightarrow> xs e ! x = Suc 0))"])
       apply (simp add: spec_def put_def put_state_def get_state_def high_Env_def swap_def)
    apply linarith
     apply(intro allI; simp)
    apply(intro get_rule;intro allI; simp)
       apply (simp add: spec_def put_def put_state_def get_state_def xs_Env_def swap_def)
  defer
   apply(simp add: inc_index_def)
   apply(intro get_rule;intro allI; simp)
   apply (simp add: spec_def put_def put_state_def get_state_def i_Env_def)
   apply(intro allI)
  sorry

lemma dnfp_invariantBlue_aux: "spec (\<lambda>e. \<forall>x \<ge> high e. xs e ! x = 2) (dnfp_mon v) (\<lambda>x e. \<forall>x \<ge> high e. xs e ! x = 2)"
  sorry

lemma dnfp_invariantRed: "spec (dnfp_inv1 n) (dnfp_mon n) (GG low_invariant_is_0_Env)"
  unfolding dnfp_inv1_def dnfp_pre_aux_def  GG_def low_invariant_is_0_Env_def
  apply(induction n rule: dnfp_mon.induct)
    apply(simp add: spec_def)
    apply(simp add: skip_def)
  apply(simp only: caseN)
   apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
   apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x e. \<forall>x<low e. xs e ! x = 0)"])
  apply(intro cond_rule)
 apply(simp add: inc_lowbound_def)
     apply (intro get_rule; intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x e. xs e ! low e = 0 \<and>  (\<forall>x<low e. xs e ! x = 0))"])
      apply (simp add: spec_def put_def put_state_def swap_def get_state_def xs_Env_def)
   apply auto[1]
  apply(intro allI; simp)
  apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x e. xs e ! low e = 0 \<and> (\<forall>x<low e. xs e ! x = 0))"])
   apply (simp add: spec_def put_def put_state_def get_state_def i_Env_def)
  apply(intro allI; simp)
  apply(intro get_rule; intro allI)
     apply (simp add: spec_def put_def put_state_def get_state_def low_Env_def)
   using less_antisym apply blast
     apply(simp add: dec_highbound_def)
     apply (intro get_rule; intro allI; simp)
      apply(intro seq_rule[of _ _ "(\<lambda>x e. (\<forall>x<low e. xs e ! x = 0) \<and> high e \<le> length (xs e) \<and> high e \<ge> i e \<and> low e \<le> i e)"]) 
       apply (simp add: spec_def get_def put_def get_state_def put_state_def high_Env_def)
       apply(linarith)
      apply(intro allI; simp)
     apply (intro get_rule; intro allI; simp)
      apply (simp add: spec_def get_def put_def get_state_def put_state_def xs_Env_def swap_def)
     apply(simp add: inc_index_def)
     apply (intro get_rule; intro allI; simp)
     apply (simp add: spec_def get_def put_def get_state_def put_state_def i_Env_def)
    apply(intro allI; simp)
   using dnfp_invariantRed_aux apply blast
    apply(simp add: spec_def)
   by(simp add: skip_def)

lemma dnfp_invariantWhite: "spec (dnfp_inv2 n) (dnfp_mon n) (GG invariant_low_to_j_is_1_Env)"
  unfolding dnfp_inv2_def dnfp_pre_aux_def  GG_def invariant_low_to_j_is_1_Env_def
  apply(induction n rule: dnfp_mon.induct)
    apply(simp add: spec_def)
    apply(simp add: skip_def)
  apply(simp only: caseN)
   apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
   apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x e. \<forall>x. low e \<le> x \<and> x < i e \<longrightarrow> xs e ! x = Suc 0)"])
  apply(intro cond_rule)
     apply(simp add: inc_lowbound_def)
     apply (intro get_rule; intro allI; simp)
   apply (simp add: spec_def put_def put_state_def  get_state_def xs_Env_def swap_def get_def i_Env_def low_Env_def return_def)
   apply(intro allI)
     apply (simp add: nth_list_update)
     apply(simp add: dec_highbound_def)
        apply(intro get_rule; intro allI; simp)
    apply(intro seq_rule[of _ _ "(\<lambda>x e. low e \<le> i e \<and> high e \<ge> i e \<and> length (xs e) > high e \<and> (\<forall>x. low e \<le> x \<and> x < i e \<longrightarrow> xs e ! x = Suc 0))"])
     apply (simp add: spec_def put_def put_state_def get_state_def high_Env_def swap_def)
    apply linarith
     apply(intro allI; simp)
    apply(intro get_rule;intro allI; simp)
   apply (simp add: spec_def put_def put_state_def get_state_def xs_Env_def swap_def)
   apply(simp add: inc_index_def)
   apply(intro get_rule;intro allI; simp)
   apply (simp add: spec_def put_def put_state_def get_state_def i_Env_def)
    apply(intro allI)
    apply (metis Suc_lessI less_SucE)
    apply(intro allI)
   using dnfp_invariantWhite_aux apply blast
    apply(simp add: spec_def)
   by(simp add: skip_def)

lemma dnfp_invariantBlue: "spec (dnfp_inv3 n) (dnfp_mon n) (GG high_invariant_is_2_Env)"
  unfolding dnfp_inv3_def dnfp_pre_aux_def  GG_def high_invariant_is_2_Env_def
  apply(induction n rule: dnfp_mon.induct)
    apply(simp add: spec_def)
    apply(simp add: skip_def)
  apply(simp only: caseN)
   apply(intro get_rule; intro allI; clarify)
  apply(intro cond_rule)
  apply(simp add: loop_update_action_def)
   apply(intro get_rule; intro allI; clarify)
  apply(intro seq_rule[of _ _ "(\<lambda>x e. (\<forall>x. high e \<le> x \<and> x < length (xs e) \<longrightarrow> xs e ! x = 2))"])
   apply (intro cond_rule)
     apply(simp add: inc_lowbound_def) 
     apply(intro get_rule;intro allI; simp)
  apply(intro seq_rule[of _ _ "(\<lambda>x e. \<forall>x. high e \<le> x \<and> x < length (xs e) \<longrightarrow> xs e ! x = 2)"])
   apply (simp add: spec_def put_def put_state_def swap_def get_state_def xs_Env_def)
  apply(intro allI; simp)
  apply(intro get_rule; intro allI)
  apply(intro seq_rule[of _ _ "(\<lambda>x e. \<forall>x. high e \<le> x \<and> x < length (xs e) \<longrightarrow> xs e ! x = 2)"])
   apply (simp add: spec_def put_def put_state_def get_state_def i_Env_def)
  apply(intro allI; simp)
  apply(intro get_rule; intro allI)
     apply (simp add: spec_def put_def put_state_def get_state_def low_Env_def)
    apply(simp_all add: dec_highbound_def)
     apply(intro get_rule; intro allI)
     apply (simp add: spec_def put_def put_state_def get_state_def high_Env_def xs_Env_def swap_def get_def)
     apply(intro allI)
   defer
   apply(simp add: inc_index_def)
    apply(intro get_rule; intro allI; simp)
     apply (simp add: spec_def put_def put_state_def get_state_def i_Env_def)
  defer
  apply(simp add: spec_def)
   apply(simp add: skip_def)
   sorry

 text\<open>Main proof\<close>
definition dnfp_mon_inv :: "nat \<Rightarrow> env \<Rightarrow> bool" where
"dnfp_mon_inv n e \<equiv> ((dnfp_inv3 n e) \<and>  (dnfp_inv2 n e) \<and> (dnfp_inv1 n e))"

lemma dnfp_mon_invariants: "spec (dnfp_mon_inv n) (dnfp_mon n) (GG invariants_Env)"
  by (smt GG_def dnfp_invariantBlue dnfp_invariantRed dnfp_invariantWhite dnfp_mon_inv_def invariants_Env_def spec_def split_def)

definition dnfp_post_spec where
"dnfp_post_spec e \<equiv> invariants_Env e \<and> i e = high e"

lemma dnfp_mon_isSorted: "dnfp_post_spec e \<Longrightarrow> sorted (xs e)" 
  unfolding  dnfp_post_spec_def high_invariant_is_2_Env_def invariant_low_to_j_is_1_Env_def invariants_Env_def low_invariant_is_0_Env_def
  by (smt add_diff_cancel_left' diff_is_0_eq' le_less_trans less_Suc_eq_0_disj  not_less not_less_eq_eq numeral_2_eq_2 plus_1_eq_Suc sorted_iff_nth_mono)

definition dnfp_post_spec1 where
"dnfp_post_spec1 e \<equiv> invariants_Env e \<and> i e = high e \<and> sorted(xs e)"

lemma dnfp_mon_main: "spec (dnfp_mon_inv n) (dnfp_mon n) (GG (dnfp_post_spec1))"
  unfolding GG_def dnfp_post_spec1_def
  apply(intro conj_rule_right)
  apply (metis GG_def dnfp_mon_invariants strengthen_rule)
  unfolding dnfp_mon_inv_def dnfp_inv3_def dnfp_inv2_def dnfp_inv1_def dnfp_pre_aux_def
   apply (smt case_prod_beta' dnfp_aux7 spec_def)  
  by (smt GG_def case_prod_beta' dnfp_aux7 dnfp_inv1_def dnfp_inv2_def dnfp_inv3_def dnfp_mon_inv_def dnfp_mon_invariants dnfp_mon_isSorted dnfp_post_spec_def dnfp_pre_aux_def spec_def)



end